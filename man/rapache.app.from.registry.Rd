% Generated by roxygen2 (4.0.2): do not edit by hand
\name{rapache.app.from.registry}
\alias{rapache.app.from.registry}
\title{rapache.app.from.registry}
\usage{
rapache.app.from.registry(registry, page.param = "page",
  textarea.wrap.param = "textarea_wrap", device.param = "device",
  decoder.param = "decoder", max.regions.param = "max_annotated_regions",
  default.max.regions = 10000, force = FALSE,
  tmpdir = Sys.getenv("WEB_TMPDIR"), tmpdir.timeout.seconds = 600,
  devices = .default.device.list, other.mime.types = c(json =
  "application/json"), mime.types = c(sapply(devices, "[[", "mime.type"),
  other.mime.types),
  query.param.decoders = .build.default.query.param.decoders(),
  brand.builder = .default.brand.builder, logger = create.logger(stderr(),
  log4r:::FATAL))
}
\arguments{
\item{registry}{AnalysisPageRegistry from which to build you app.}

\item{page.param}{Character. Name for the parameter which specifies the page. Default "page"}

\item{textarea.wrap.param}{Character. Name for the parameter which specifies whether the response should be wrapped in a \code{<textarea>} tag.
This is needed to support file uploads in browsers, like IE9, that don't support XMLHttpRequest2. Default "textarea_wrap". In addition
to wrapping in textarea the response type will be set to "text/html", another hack that such browsers require.}

\item{device.param}{Character. Name for the parameter which specifices the plotting device. Default: "device".}

\item{decoder.param}{Character. Name for the parameter which specifices the form query parameter decoding method. Default: "decoder".}

\item{max.regions.param}{String. Name for the parameter which specifies the maximum number of regions for annotation. Default: "max_annotated_regions".}

\item{default.max.regions}{Default maximum number of regions for annotation. If a plot has more than this many elements then it will not be annotated.
Default: 10000.}

\item{force}{Logical. If set then an invalid registry is a warning instead of an error.}

\item{tmpdir}{Temporary directory into which plot files should be written. By default this
is taken from the WEB_TMPDIR environment variable. It is checked upon opening. It is important
under Apache that all of the processes use the same directory, otherwise they won't be able
to find the plots made by other processes.}

\item{tmpdir.timeout.seconds}{Temporary files will expire after this time. Default: 600 (10 minutes)}

\item{devices}{Named list. The names of the vector are the names of allowed plotting devices. The values
are themselves lists, each having a \code{$mime.type} and \code{$function}, being the ploting function.
Default is given by the private variable \code{.default.device.list}, and includes svg and png (but
uses a modified png function so that it accepts units inches).
Which one to be used (in the default scenario, a choice between \code{svg} and \code{png})
is controlled by the special \code{device.param} parameter. If that is not provided
then the first device from this vector is used (default default is therefore "svg", which is the
best since it can be annotated, but older browsers such as IE8 will need to do PNGs).}

\item{other.mime.types}{Named charvec giving a mapping from file extensions other than those
already in \code{devices} to MIME types that can be served out of the temporary storage/retrieval area.
Default: \code{c(json = "application/json")}.}

\item{mime.types}{This is a named charvec giving a mapping from file extensions to mime types. Only files with
extensions in this list can be served from the temporary storage/retrieval area. The default is to
take the extensions/MIME-types defined in \code{devices} and add to them those in \code{other.mime.tpyes}.}

\item{query.param.decoders}{Names list. The names are the names of allowed query param decoders (valid values for
the \code{decoder.param} parameter). The values are functions which do the decoding. Default is just \code{list(url=urlDecode)}.
\code{urlDecode} is a function supplied by RApache (or by testing framework).}

\item{brand.builder}{This is a function that takes a single argument called "persistent" which is a list of key value pairs representing
the internal "persistent" state of the app. The persistent state is a namespace that particular parameters of particular pages
can draw from, with the possible option of locking those parameters to the values in the persistent namespace. The purpose of the
\code{brand.builder} function is to return a string that should be used in the top-left corner of the web page to briefly summarize
the current state. The default brand builder always returns the string "AnalysisPageServer".}

\item{logger}{log4r object, optional}
}
\value{
AnalysisPageRApacheApp
}
\description{
Build rapache app from an AnalysisPageRegistry
}
\details{
This does most but not all of the work. You should create an R script that builds your page registry, then
builds an rapache.app with this function. Within that R script you call add.handlers.to.global to install
the 5 handlers (handle.pages/handle.params/handle.plot/handle.data/handle.meta.data).

Next you have to tell apache to source your script upon startup. The directive for your httpd.conf is as follows:
\code{RSourceOnStartup "/gne/home/friedmab/scr/apache-test/R-startup.R"}

Finally, you have to register the five handlers. This is done as follows
}
\author{
Brad Friedman
}

