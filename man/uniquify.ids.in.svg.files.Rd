% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/annotator.R
\name{uniquify.ids.in.svg.files}
\alias{uniquify.ids.in.svg.files}
\title{uniquify.ids.in.svg.files}
\usage{
uniquify.ids.in.svg.files(svg.filenames,
  suffixes = unique.words(length(svg.filenames)),
  prefixes = .default.uniquify.ids.prefixes)
}
\arguments{
\item{svg.filenames}{Paths to SVG files}

\item{suffixes}{Charvec. Suffixes to add to IDs, corresponding
to \code{svg.filenames}.
These is added after the word "glyph" and before the next character.
An underscore character is added on both sides, too, to separate
your suffix visually from the word "glyph" and the numbers after it.
Ignored if \code{new.glyph.word} is provided.}

\item{prefixes}{Named list. The names are the tokens that need to be
replaced, such as "glyph" and "path". The values are charvec of prefixes.
Only when those words appear after one of their prefixes is it
substituted. Default is taken from
\code{AnalysisPageServer:::.default.uniquify.ids.prefixes}.}
}
\value{
Nothing, modifies SVG file in place.
}
\description{
Uniquify IDs in a set of SVG filename
}
\details{
The SVG files made by R use identifiers like "glyph1-3", "glyph1-4" etc.
In particular these are used to define paths for different characters
in order to render text. Also there are "clip1", "clip2" etc which represent
clip paths, which I think limits the viewable area in a layer of a plot,
but whatever it is looks awful if it goes wrong.

If multiple SVG files are embedded in the same page then this is a big
problem because they will all share the same namespace and may
grab the paths defined in a different file.

This function will process a set of SVG files replacing each word "glyph"
with a file-specfic suffix like "glyph_123_", and each word "clip"
with "clip_123_" You can provide the
suffixes explicitly or let this function generate some random words,
one for each file.

This function does search-and-replace with these two cleverness-es:
\enumerate{
  \item{It uses C++ so it is faster (I hope) than calling \code{gsub}.}
  \item{It checks the context of the words "glyph" and "clip", so if you had an SVG
        containing that word other than identifier it should be preserved. This
        is not 100\% bulletproof since it doesn't actually parse the SVG
        file but it should be 99.99\% bulletproof, unless you go out
        of your way to break it.}
}
}
\note{
Typical (and recommended) usage is to only provide the \code{svg.filenames}
argument and leave the rest as defaults.
}
\examples{
svg.filenames <- sapply(1:2, function(i)  {
  fn <- tempfile(fileext = ".svg")
  svg(fn)
  plot(1:10, main = paste("Plot", i), col = i)
  dev.off()
  fn
})
grep("glyph", readLines(svg.filenames[1]), value = TRUE)
uniquify.ids.in.svg.files(svg.filenames)
grep("glyph", readLines(svg.filenames[1]), value = TRUE)
}
\author{
Brad Friedman
}

