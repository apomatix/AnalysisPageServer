% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analysis.page.R
\name{execute.handler}
\alias{execute.handler}
\title{execute.handler}
\usage{
execute.handler(analysis.page, params, plot.file, file.params = list(),
  device = svg, annotate.plot = analysis.page$annotate.plot,
  max.annotated.regions = 5000, logger = create.logger(stderr(),
  log4r:::FATAL + 1))
}
\arguments{
\item{analysis.page}{AnalysisPage object}

\item{params}{Named list of parameters. These can include arguments to \code{\link{svg}}
and arguments to the handler function. If there are any extra arguments then an
error is thrown.}

\item{plot.file}{Path to file to create. Should not exist already.}

\item{file.params}{Named list of parameters (but defaults to empty list). These will be
passed through as-is and should correspond to FILE uploads (being length-2 lists with
\code{$name} and \code{$tmp_name} elements).}

\item{device}{The plotting device function to use. Default: svg. You might specify
png instead (you are passing the actual function here, not its name).}

\item{annotate.plot}{Logical, indicating whether I should try to annotate the SVG plot.
(If you aren't using the SVG device then this should be set to FALSE to not waste
time trying to annotate the plot.)
Default: \code{analysis.page$annotate.plot}}

\item{max.annotated.regions}{Integer. If the handler returns more than this
many regions then do not try to annotate them in the plot. Default: 5000}

\item{logger}{log4r object. Default: no logging (FATAL + 1)}
}
\value{
AnnotatedDataFrame, but throws error if the handler is not making a plot, or is
returning invalid data.
}
\description{
Execute the handler
}
\details{
\code{execute.handler} executes the plot function in the handler based on the
parameter list, checks that the output is valid, adds the SVG attributes to the plot,
and returns an AnnotatedDataFrame.

All of the parameters in the parameter list are JSON decoded. Even though this is
really just extra work for the scalar parameters, we do it because otherwise it is confusing
who needs to be de/encoded and who doesn't.

It is OK if your handler doesn't turn off the device when it's done. This wrapper
will check if the current device hasn't changed. If so, it will call \code{dev.off}.
This is useful because then you can use the same function in an interactive session,
and also saves you one line of code. It's also OK if your handler *does* turn off
the device. Then the current device will have decreased and the wrapper will
known not to call dev.off again.

It is also OK if your handler returns a data.frame instead of an AnnotatedDataFrame.
It just has to have \code{x}, \code{y}. An AnnotatedDataFrame will be built
The interpretation
of the fields in the AnnotatedDataFrame depend on your front end, but the guidelines
are like this:

\describe{
  \item{\code{type}}{"text", "numeric" or "none", to set sorting and filtering options.}
  \item{\code{labelDescription}}{A display name for the column, instead of showing the actual name.}
}

If \code{$no.plot} is true then the plotting device won't be opened or closed, and of course the plot won't be annotated.

If annotate.data.frame is set then your data.frame is converted to an AnnotatedDataFrame
and your AnnotatedDataFrame is converted to an AnalysisPageDataNode of "table" type
automatically.
}
\examples{
page <- new.analysis.page(AnalysisPageServer:::sine.handler)
plot.file <- tempfile(fileext = ".svg")
plist <- lapply(list(xmin=-2*pi, xmax=2*pi, n= 50), rjson::toJSON)
sine.data <- AnalysisPageServer:::execute.handler(page, plist, plot.file=plot.file)
# now sine.data is an AnnotatedDataFrame
}
\author{
Brad Friedman
}
\seealso{
\code{\link{new.analysis.page}}
}

