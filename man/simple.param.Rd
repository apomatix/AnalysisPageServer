% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/params.R
\name{simple.param}
\alias{simple.param}
\title{simple.param}
\usage{
simple.param(name, label = name, description = label, value = "",
  type = "text", advanced = 0, show.if = NULL, display.callback = NULL,
  size = "medium", required = TRUE, persistent = NULL,
  persistent.dependencies = NULL, transformer = NULL)
}
\arguments{
\item{name}{Name of form element}

\item{label}{Label for form element (typically rendered to the left of the element)}

\item{description}{Description for form element (typically rendered as roll-over text)}

\item{value}{The default, starting value, for the form (default: "")}

\item{type}{Type of form element. This can be "text", "textarea", "checkbox", "password" or "file"}

\item{advanced}{Integer. 0 means the option is not advanced, and increasing levels indicate the option
is for more advanced users. Advanced > 0 should be hidden under default mode.}

\item{show.if}{A list of two elements: \code{$name}, giving the name of some other param in the set
and \code{$values}, a character vector of values. The parameter under construction should only be shown if
the named parameter takes on any of the values in the \code{$values} vector. Default (NULL) is to always
show the parameter under construction.}

\item{display.callback}{NULL, to follow \code{show.if} logic in deciding when/if
to display the element, or a list with the two elements \code{$uri} and \code{$dependent},
which follow the same format as the corresponding arguments to \code{combobox.param} and provide
a templated uri and a mapping from template variables to form parameters. The service should
return JSON true if the widget is to be shown and false if not. It is allowed to
have both a \code{display.callback} and a \code{show.if}---both conditions must be
met in order to display the element.}

\item{size}{A word giving the size of the element. The interpretation of this size is up to the front-end.
Must from a defined set of words, which you can see by calling \code{known.param.sizes()} (currently
no way to change this). Default: medium}

\item{required}{Logical. Is this a required param? Default: TRUE. If set, then the front-end will
the front-end user is required to set this parameter before submitting the request. The meaning of
"set this parameter" is not entirely clear.}

\item{persistent}{Character or NULL. If non-NULL then it is passed to the front-end. It names a
variable in persistent storage that should be used to initialize the value of the parameter.
The front end will provide some mechanism to change the persistent value, but until the user does
so the param will be initialized from the value in the persistent space.}

\item{persistent.dependencies}{A character vector or NULL (default) specifying the names
of other parameters on
which this one "depends". It is an error to include the parameter itself (\code{name}).
It is an error to provide this when \code{persistent} is NULL.
When \code{persistent} is non-NULL, providing \code{persistent.dependencies} makes this parameter
not just "persistent" but "conditionally persistent", which
is to say that the persistent value for this parameter is actually a hash lookup based on the
the other parameters specified in this vector. A typical example would be a pheno fields parameter
which is dependent on the study parameter. The names are taken from the Page namespace, which
means that a parameter's \code{$name} is used when this differs from its \code{$persistent}
slot.}

\item{transformer}{A function with signature \code{function(value, self)} or \code{function(value)} which accepts
as first argument the JSON-decoded value of the parameter returned from the front end and then performs
some sort of transformation. The return value of the function will be ultimately
passed to AnalysisPage handler. For example, for a field which is a simple text widget
but which is supposed to be numeric you might use \code{transformer = as.numeric}. But you could
also implement more complicated logic here. The reason to put the logic here instead of in the handler
is that it makes it easier to re-use the widget in multiple handlers. If you have a complex (nested) parameter
then the nested elements' transformations, if any, are applied first, then the parental transformation is applied.
Or, NULL (default) to not
do any transformation beyond the JSON decoding.}
}
\value{
An AnalysisPageParam. This is just a list with class name slapped on.
}
\description{
Build a simple AnalysisPageParam
}
\details{
Build a simple AnalysisPageParam. These include mainly parameters that can be rendered simply as HTML <input> tags.
}
\examples{
  x <- simple.param("xmin", label="X-min", description="Minimum x value", type="text")
  # Please see the "Persistent Parameters" and "Conditionally Persistent Parameters"
  # sections of the Interactive Apps vignette for demonstrations of these functionalities
}
\author{
Brad Friedman
}

